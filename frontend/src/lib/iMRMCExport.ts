/**
 * iMRMCExport.ts
 * 
 * P3: iMRMC (Image-based Multi-Reader Multi-Case) export format
 * Generates data files compatible with FDA iMRMC software for
 * reader study analysis
 * 
 * Reference: https://github.com/DIDSR/iMRMC
 */

// ============================================================================
// TYPES
// ============================================================================

export interface ReaderScore {
  readerId: string;
  caseId: string;
  modality: string;  // e.g., 'HUMAN_ONLY', 'AI_ASSISTED', 'AI_ONLY'
  score: number;     // Continuous score (0-100) or BI-RADS (0-6)
}

export interface CaseTruth {
  caseId: string;
  truth: 0 | 1;      // 0 = negative, 1 = positive (cancer)
}

export interface iMRMCConfig {
  studyName: string;
  studyDate: string;
  description: string;
  modalities: string[];
  scoringType: 'CONTINUOUS' | 'ORDINAL';
  primaryEndpoint: 'AUC' | 'SENSITIVITY' | 'SPECIFICITY';
}

export interface iMRMCDataset {
  config: iMRMCConfig;
  readers: string[];
  cases: string[];
  truths: CaseTruth[];
  scores: ReaderScore[];
}

export interface iMRMCAnalysisResult {
  modalityA: string;
  modalityB: string;
  aucA: number;
  aucB: number;
  aucDiff: number;
  aucDiffSE: number;
  pValue: number;
  ci95Lower: number;
  ci95Upper: number;
}

// ============================================================================
// iMRMC DATA FILE GENERATOR
// ============================================================================

export class iMRMCExporter {
  private dataset: iMRMCDataset;

  constructor(config: iMRMCConfig) {
    this.dataset = {
      config,
      readers: [],
      cases: [],
      truths: [],
      scores: [],
    };
  }

  /**
   * Add a reader to the study
   */
  addReader(readerId: string): void {
    if (!this.dataset.readers.includes(readerId)) {
      this.dataset.readers.push(readerId);
    }
  }

  /**
   * Add a case with ground truth
   */
  addCase(caseId: string, truth: 0 | 1): void {
    if (!this.dataset.cases.includes(caseId)) {
      this.dataset.cases.push(caseId);
      this.dataset.truths.push({ caseId, truth });
    }
  }

  /**
   * Add a reader score for a case
   */
  addScore(score: ReaderScore): void {
    this.dataset.scores.push(score);
  }

  /**
   * Generate iMRMC input file format (.imrmc)
   * This is the format expected by the FDA iMRMC software
   */
  generateIMRMCFile(): string {
    const lines: string[] = [];
    
    // Header comments
    lines.push(`// iMRMC Input File`);
    lines.push(`// Generated by Evidify Export System`);
    lines.push(`// Study: ${this.dataset.config.studyName}`);
    lines.push(`// Date: ${this.dataset.config.studyDate}`);
    lines.push(`// Description: ${this.dataset.config.description}`);
    lines.push('');
    
    // Configuration section
    lines.push(`N0: ${this.dataset.truths.filter(t => t.truth === 0).length}`);
    lines.push(`N1: ${this.dataset.truths.filter(t => t.truth === 1).length}`);
    lines.push(`NR: ${this.dataset.readers.length}`);
    lines.push(`NM: ${this.dataset.config.modalities.length}`);
    lines.push('');
    
    // Begin data section
    lines.push('BEGIN DATA:');
    
    // Data format: reader, case, modality, score
    for (const score of this.dataset.scores) {
      const readerIdx = this.dataset.readers.indexOf(score.readerId);
      const caseIdx = this.dataset.cases.indexOf(score.caseId);
      const modalityIdx = this.dataset.config.modalities.indexOf(score.modality);
      const truth = this.dataset.truths.find(t => t.caseId === score.caseId);
      
      if (readerIdx >= 0 && caseIdx >= 0 && modalityIdx >= 0 && truth) {
        // Format: readerID, caseID, modalityID, score
        lines.push(`${readerIdx},${truth.truth},${caseIdx},${modalityIdx},${score.score}`);
      }
    }
    
    return lines.join('\n');
  }

  /**
   * Generate CSV format (alternative to .imrmc)
   */
  generateCSV(): string {
    const lines: string[] = [];
    
    // Header
    lines.push('reader_id,case_id,modality,truth,score');
    
    // Data rows
    for (const score of this.dataset.scores) {
      const truth = this.dataset.truths.find(t => t.caseId === score.caseId);
      if (truth) {
        lines.push(`${score.readerId},${score.caseId},${score.modality},${truth.truth},${score.score}`);
      }
    }
    
    return lines.join('\n');
  }

  /**
   * Generate R script for analysis
   */
  generateRScript(): string {
    return `# iMRMC Analysis Script for ${this.dataset.config.studyName}
# Generated by Evidify Export System
# Date: ${new Date().toISOString()}

# ============================================================================
# SETUP
# ============================================================================

# Install iMRMC package if needed
if (!require("iMRMC")) {
  install.packages("iMRMC")
}
library(iMRMC)
library(tidyverse)

# ============================================================================
# LOAD DATA
# ============================================================================

# Load the CSV data file
data <- read_csv("imrmc_data.csv", show_col_types = FALSE)

# Convert to iMRMC format
imrmc_data <- data %>%
  mutate(
    readerID = reader_id,
    caseID = case_id,
    modalityID = modality,
    score = score
  ) %>%
  select(readerID, caseID, modalityID, score)

# Truth data
truth_data <- data %>%
  distinct(case_id, truth) %>%
  rename(caseID = case_id)

# ============================================================================
# RUN iMRMC ANALYSIS
# ============================================================================

# Create iMRMC dataset object
study <- createIMRMCdf(
  data = imrmc_data,
  truth = truth_data,
  modalities = c(${this.dataset.config.modalities.map(m => `"${m}"`).join(', ')})
)

# Run analysis
results <- doIMRMC(study)

# ============================================================================
# RESULTS
# ============================================================================

# Print summary
cat("\\n========================================\\n")
cat("iMRMC Analysis Results\\n")
cat("Study: ${this.dataset.config.studyName}\\n")
cat("========================================\\n\\n")

# AUC estimates per modality
cat("AUC Estimates:\\n")
print(results$AUC)

# Between-modality comparison
cat("\\nModality Comparison (${this.dataset.config.modalities[0]} vs ${this.dataset.config.modalities[1] || 'N/A'}):\\n")
print(results$diffAUC)

# Confidence intervals
cat("\\n95% Confidence Intervals:\\n")
print(results$CI)

# ============================================================================
# SAVE RESULTS
# ============================================================================

# Save to CSV
write_csv(results$AUC, "results_auc.csv")
write_csv(results$diffAUC, "results_comparison.csv")

# Save full results object
saveRDS(results, "imrmc_results.rds")

cat("\\nResults saved to: results_auc.csv, results_comparison.csv, imrmc_results.rds\\n")
`;
  }

  /**
   * Get dataset summary
   */
  getSummary(): {
    nReaders: number;
    nCases: number;
    nPositive: number;
    nNegative: number;
    nScores: number;
    modalities: string[];
    scoresByModality: Record<string, number>;
  } {
    const scoresByModality: Record<string, number> = {};
    for (const score of this.dataset.scores) {
      scoresByModality[score.modality] = (scoresByModality[score.modality] || 0) + 1;
    }

    return {
      nReaders: this.dataset.readers.length,
      nCases: this.dataset.cases.length,
      nPositive: this.dataset.truths.filter(t => t.truth === 1).length,
      nNegative: this.dataset.truths.filter(t => t.truth === 0).length,
      nScores: this.dataset.scores.length,
      modalities: this.dataset.config.modalities,
      scoresByModality,
    };
  }

  /**
   * Export all files as a package
   */
  exportAll(): {
    'imrmc_input.imrmc': string;
    'imrmc_data.csv': string;
    'analysis_script.R': string;
    'study_summary.json': string;
  } {
    return {
      'imrmc_input.imrmc': this.generateIMRMCFile(),
      'imrmc_data.csv': this.generateCSV(),
      'analysis_script.R': this.generateRScript(),
      'study_summary.json': JSON.stringify(this.getSummary(), null, 2),
    };
  }
}

// ============================================================================
// CONVERSION UTILITIES
// ============================================================================

/**
 * Convert Evidify metrics to iMRMC format
 */
export function convertEvidifyToIMRMC(
  sessions: Array<{
    sessionId: string;
    participantId: string;
    condition: string;
    cases: Array<{
      caseId: string;
      initialBirads: number;
      finalBirads: number;
      groundTruth?: number;
    }>;
  }>,
  config: Partial<iMRMCConfig> = {}
): iMRMCExporter {
  const fullConfig: iMRMCConfig = {
    studyName: config.studyName || 'Evidify Study',
    studyDate: config.studyDate || new Date().toISOString().split('T')[0],
    description: config.description || 'Exported from Evidify platform',
    modalities: config.modalities || ['HUMAN_ONLY', 'AI_ASSISTED'],
    scoringType: config.scoringType || 'ORDINAL',
    primaryEndpoint: config.primaryEndpoint || 'AUC',
  };

  const exporter = new iMRMCExporter(fullConfig);

  for (const session of sessions) {
    exporter.addReader(session.participantId);

    for (const case_ of session.cases) {
      // Add case with truth (default to 0 if not provided)
      const truth = (case_.groundTruth !== undefined && case_.groundTruth >= 4) ? 1 : 0;
      exporter.addCase(case_.caseId, truth as 0 | 1);

      // Add initial score (HUMAN_ONLY)
      exporter.addScore({
        readerId: session.participantId,
        caseId: case_.caseId,
        modality: 'HUMAN_ONLY',
        score: case_.initialBirads,
      });

      // Add final score (AI_ASSISTED)
      exporter.addScore({
        readerId: session.participantId,
        caseId: case_.caseId,
        modality: 'AI_ASSISTED',
        score: case_.finalBirads,
      });
    }
  }

  return exporter;
}

/**
 * Calculate ROC curve points from scores
 */
export function calculateROCPoints(
  scores: ReaderScore[],
  truths: CaseTruth[]
): Array<{ threshold: number; tpr: number; fpr: number }> {
  const truthMap = new Map(truths.map(t => [t.caseId, t.truth]));
  const points: Array<{ threshold: number; tpr: number; fpr: number }> = [];
  
  // Get unique thresholds
  const thresholds = [...new Set(scores.map(s => s.score))].sort((a, b) => b - a);
  
  const nPositive = truths.filter(t => t.truth === 1).length;
  const nNegative = truths.filter(t => t.truth === 0).length;

  for (const threshold of thresholds) {
    let tp = 0, fp = 0;
    
    for (const score of scores) {
      const truth = truthMap.get(score.caseId);
      if (truth === undefined) continue;
      
      if (score.score >= threshold) {
        if (truth === 1) tp++;
        else fp++;
      }
    }
    
    points.push({
      threshold,
      tpr: nPositive > 0 ? tp / nPositive : 0,
      fpr: nNegative > 0 ? fp / nNegative : 0,
    });
  }

  return points;
}

/**
 * Calculate AUC using trapezoidal rule
 */
export function calculateAUC(rocPoints: Array<{ tpr: number; fpr: number }>): number {
  // Sort by FPR
  const sorted = [...rocPoints].sort((a, b) => a.fpr - b.fpr);
  
  let auc = 0;
  for (let i = 1; i < sorted.length; i++) {
    const width = sorted[i].fpr - sorted[i - 1].fpr;
    const height = (sorted[i].tpr + sorted[i - 1].tpr) / 2;
    auc += width * height;
  }
  
  return auc;
}

export default iMRMCExporter;
